//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiException = exports.UserSex = exports.OKResponse = exports.Sort3 = exports.Mode = exports.Sort2 = exports.Sort = exports.Vote = exports.Client = void 0;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
class Client {
    constructor(baseUrl, http) {
        this.jsonParseReviver = undefined;
        this.http = http ? http : window;
        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : "https://dev.metahkg.org/api";
    }
    /**
     * Get thread
     * @param id thread id
     * @param page (optional) Page number. Ignored if start and end both specified.
     * @param limit (optional) Limit of comments per page.
     * @param sort (optional) Sort comments by score / time / latest. "time" means sorting acsendingly by created time, "latest" means desceningly, "score" means sorting descendingly by `upvotes - downvotes`
     * @param start (optional) Starting from comment id. If end is specified but start is not, start default to `(page - 1) * limit + 1`
     * @param end (optional) Ending at comment id. Must be greater or equal to start. If start is specified but end is not, end defaults to `page * limit`
     * @return Success
     */
    thread(id, page, limit, sort, start, end) {
        let url_ = this.baseUrl + "/thread/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processThread(_response);
        });
    }
    processThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403 = null;
                result403 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Check if a thread exists
     * @param id thread id
     * @return OK
     */
    threadCheck(id) {
        let url_ = this.baseUrl + "/thread/check?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processThreadCheck(_response);
        });
    }
    processThreadCheck(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get thread images
     * @param id thread id
     * @return Success
     */
    threadImages(id) {
        let url_ = this.baseUrl + "/thread/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processThreadImages(_response);
        });
    }
    processThreadImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Create thread
     * @param body (optional)
     * @return Success
     */
    threadCreate(body) {
        let url_ = this.baseUrl + "/thread/create";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processThreadCreate(_response);
        });
    }
    processThreadCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Category not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Recaptcha token invalid", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    comment(id, cid) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processComment(_response);
        });
    }
    processComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get replies
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentReplies(id, cid) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/replies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentReplies(_response);
        });
    }
    processCommentReplies(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410 = null;
                result410 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Comment removed", status, _responseText, _headers, result410);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment images.
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentImages(id, cid) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentImages(_response);
        });
    }
    processCommentImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410 = null;
                result410 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Comment removed", status, _responseText, _headers, result410);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Create comment
     * @param id thread id
     * @param body (optional)
     * @return Success
     */
    commentCreate(id, body) {
        let url_ = this.baseUrl + "/thread/{id}/comment/create";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentCreate(_response);
        });
    }
    processCommentCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Recaptcha token invalid", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Vote on comment
     * @param body (optional)
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentVote(id, cid, body) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentVote(_response);
        });
    }
    processCommentVote(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410 = null;
                result410 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Comment removed", status, _responseText, _headers, result410);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User has already voted", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Pin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentPin(id, cid) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentPin(_response);
        });
    }
    processCommentPin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410 = null;
                result410 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Comment removed", status, _responseText, _headers, result410);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Unpin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentUnpin(id, cid) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/unpin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCommentUnpin(_response);
        });
    }
    processCommentUnpin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread or comment not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Comment not pinned", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get status
     * @return Success
     */
    meStatus() {
        let url_ = this.baseUrl + "/me/status";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeStatus(_response);
        });
    }
    processMeStatus(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get blocked users
     * @return Success
     */
    meBlocked() {
        let url_ = this.baseUrl + "/me/blocked";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeBlocked(_response);
        });
    }
    processMeBlocked(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get votes
     * @param id thread id
     * @return Success
     */
    meVotes(id) {
        let url_ = this.baseUrl + "/me/votes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeVotes(_response);
        });
    }
    processMeVotes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Thread not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Block user
     * @return OK
     */
    meBlock() {
        let url_ = this.baseUrl + "/me/block";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeBlock(_response);
        });
    }
    processMeBlock(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User already blocked", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Unblock user
     * @return OK
     */
    meUnblock() {
        let url_ = this.baseUrl + "/me/unblock";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeUnblock(_response);
        });
    }
    processMeUnblock(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not blocked", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Set avatar
     * @param avatar (optional) Avatar image. Must be smaller than 2MB. Png, jpg, jpeg, jfif, svg, gif, webp are supported.
     * @return OK
     */
    meAvatar(avatar) {
        let url_ = this.baseUrl + "/me/avatar";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = new FormData();
        if (avatar === null || avatar === undefined)
            throw new Error("The parameter 'avatar' cannot be null.");
        else
            content_.append("avatar", avatar.data, avatar.fileName ? avatar.fileName : "avatar");
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeAvatar(_response);
        });
    }
    processMeAvatar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 413) {
            return response.text().then((_responseText) => {
                let result413 = null;
                result413 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("File too large", status, _responseText, _headers, result413);
            });
        }
        else if (status === 415) {
            return response.text().then((_responseText) => {
                let result415 = null;
                result415 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("File type not supported", status, _responseText, _headers, result415);
            });
        }
        else if (status === 422) {
            return response.text().then((_responseText) => {
                let result422 = null;
                result422 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("File unprocessable", status, _responseText, _headers, result422);
            });
        }
        else if (status === 500) {
            return response.text().then((_responseText) => {
                let result500 = null;
                result500 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Internal server error", status, _responseText, _headers, result500);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Rename
     * @param body (optional)
     * @return Success
     */
    meRename(body) {
        let url_ = this.baseUrl + "/me/rename";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMeRename(_response);
        });
    }
    processMeRename(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Name already taken", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get categories
     * @return Success
     */
    categories() {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCategories(_response);
        });
    }
    processCategories(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get category
     * @param id category id, or `bytid<thread id>`
     * @return Success
     */
    category(id) {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCategory(_response);
        });
    }
    processCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Category not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get user profile
     * @param id user id
     * @return Success
     */
    usersProfile(id) {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersProfile(_response);
        });
    }
    processUsersProfile(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get user name
     * @param id user id
     * @return Success
     */
    usersProfileName(id) {
        let url_ = this.baseUrl + "/users/{id}/name";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersProfileName(_response);
        });
    }
    processUsersProfileName(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get user avatar
     * @param id user id
     * @return Success
     */
    usersProfileAvatar(id) {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "image/png",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersProfileAvatar(_response);
        });
    }
    processUsersProfileAvatar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then((blob) => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers,
                };
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Login
     * @param body (optional)
     * @return Success
     */
    usersLogin(body) {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersLogin(_response);
        });
    }
    processUsersLogin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Login failed", status, _responseText, _headers, result401);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Email verification needed", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Register
     * @param body (optional)
     * @return Success, verification email sent.
     */
    usersRegister(body) {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersRegister(_response);
        });
    }
    processUsersRegister(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException("Bad request / registration disabled / invalid invite code", status, _responseText, _headers);
            });
        }
        else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409 = null;
                result409 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Email or username already in use", status, _responseText, _headers, result409);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Verify email
     * @param body (optional)
     * @return Success
     */
    usersVerify(body) {
        let url_ = this.baseUrl + "/users/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersVerify(_response);
        });
    }
    processUsersVerify(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401 = null;
                result401 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Code incorrect or expired / email not found", status, _responseText, _headers, result401);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Resend verification email
     * @param body (optional)
     * @return Success
     */
    usersResend(body) {
        let url_ = this.baseUrl + "/users/resend";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersResend(_response);
        });
    }
    processUsersResend(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Email not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Too many requests / ReCAPTCHA token invalid", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Forgot password
     * @param body (optional)
     * @return Success
     */
    usersForgot(body) {
        let url_ = this.baseUrl + "/users/forgot";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersForgot(_response);
        });
    }
    processUsersForgot(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Too many requests / ReCAPTCHA token invalid", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Reset password
     * @param body (optional)
     * @return Success
     */
    usersReset(body) {
        let url_ = this.baseUrl + "/users/reset";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUsersReset(_response);
        });
    }
    processUsersReset(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429 = null;
                result429 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Too many requests", status, _responseText, _headers, result429);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads in a category
     * @param category category id
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuCategory(category, sort, page, limit) {
        let url_ = this.baseUrl + "/menu/{category}?";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMenuCategory(_response);
        });
    }
    processMenuCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Category not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Search threads
     * @param q Search query
     * @param mode (optional) Search mode. `0: title` or `1: op`
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuSearch(q, mode, sort, page, limit) {
        let url_ = this.baseUrl + "/menu/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMenuSearch(_response);
        });
    }
    processMenuSearch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads created by a user
     * @param id user id
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuHistory(id, page, limit) {
        let url_ = this.baseUrl + "/menu/history/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMenuHistory(_response);
        });
    }
    processMenuHistory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404 = null;
                result404 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("User not found", status, _responseText, _headers, result404);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads
     * @param threads Thread ids
     * @return Success
     */
    menuThreads(threads) {
        let url_ = this.baseUrl + "/menu/threads?";
        if (threads === undefined || threads === null)
            throw new Error("The parameter 'threads' must be defined and cannot be null.");
        else
            threads &&
                threads.forEach((item) => {
                    url_ += "threads=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };
        return this.http.fetch(url_, options_).then((_response) => {
            return this.processMenuThreads(_response);
        });
    }
    processMenuThreads(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200 = null;
                result200 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return result200;
            });
        }
        else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400 = null;
                result400 =
                    _responseText === ""
                        ? null
                        : JSON.parse(_responseText, this.jsonParseReviver);
                return throwException("Invalid request", status, _responseText, _headers, result400);
            });
        }
        else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve(null);
    }
}
exports.Client = Client;
/** Vote. "U" means upvote. "D" means downvote. */
var Vote;
(function (Vote) {
    Vote["U"] = "U";
    Vote["D"] = "D";
})(Vote = exports.Vote || (exports.Vote = {}));
var Sort;
(function (Sort) {
    Sort["Score"] = "score";
    Sort["Time"] = "time";
    Sort["Latest"] = "latest";
})(Sort = exports.Sort || (exports.Sort = {}));
var Sort2;
(function (Sort2) {
    Sort2[Sort2["_0"] = 0] = "_0";
    Sort2[Sort2["_1"] = 1] = "_1";
})(Sort2 = exports.Sort2 || (exports.Sort2 = {}));
var Mode;
(function (Mode) {
    Mode[Mode["_0"] = 0] = "_0";
    Mode[Mode["_1"] = 1] = "_1";
})(Mode = exports.Mode || (exports.Mode = {}));
var Sort3;
(function (Sort3) {
    Sort3[Sort3["_0"] = 0] = "_0";
    Sort3[Sort3["_1"] = 1] = "_1";
})(Sort3 = exports.Sort3 || (exports.Sort3 = {}));
var OKResponse;
(function (OKResponse) {
    OKResponse["Ok"] = "ok";
})(OKResponse = exports.OKResponse || (exports.OKResponse = {}));
var UserSex;
(function (UserSex) {
    UserSex["M"] = "M";
    UserSex["F"] = "F";
})(UserSex = exports.UserSex || (exports.UserSex = {}));
class ApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isApiException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isApiException(obj) {
        return obj.isApiException === true;
    }
}
exports.ApiException = ApiException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
//# sourceMappingURL=index.js.map