//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiException = exports.isConversation = exports.isQuote = exports.isAnonymous6 = exports.isBlockedUser = exports.isFollowedUser = exports.Client = void 0;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
const axios_1 = __importDefault(require("axios"));
class Client {
    constructor(baseUrl, instance) {
        this.jsonParseReviver = undefined;
        this.instance = instance ? instance : axios_1.default.create();
        this.instance.defaults.transformResponse = [];
        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : "https://dev.metahkg.org/api";
    }
    /**
     * Get threads
     * @param id array of thread ids
     * @return Success
     */
    threads(id, cancelToken) {
        let url_ = this.baseUrl + "/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            id &&
                id.forEach((item) => {
                    url_ += "id=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreads(_response);
        });
    }
    processThreads(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Create thread
     * @return Success
     */
    threadCreate(body, cancelToken) {
        let url_ = this.baseUrl + "/threads";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadCreate(_response);
        });
    }
    processThreadCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user muted/banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Title already exists", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Recaptcha token invalid, or too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Search threads
     * @param q Search query
     * @param mode (optional) Search mode. title or op
     * @param sort (optional) Sort threads by relevance, created or lastcomment
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    threadsSearch(q, mode, sort, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/threads/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadsSearch(_response);
        });
    }
    processThreadsSearch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get thread
     * @param id thread id
     * @param page (optional) Page number. Ignored if start and end both specified.
     * @param limit (optional) Limit of comments per page.
     * @param sort (optional) Sort comments by score / time / latest. "time" means sorting acsendingly by created time, "latest" means desceningly, "score" means sorting descendingly by `upvotes - downvotes`
     * @param start (optional) Starting from comment id. If end is specified but start is not, start default to `(page - 1) * limit + 1`
     * @param end (optional) Ending at comment id. Must be greater or equal to start. If start is specified but end is not, end defaults to `page * limit`
     * @return Success
     */
    thread(id, page, limit, sort, start, end, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThread(_response);
        });
    }
    processThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Edit thread
     * @param id thread id
     * @return OK
     */
    threadEdit(id, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadEdit(_response);
        });
    }
    processThreadEdit(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or category not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Delete thread
     * @param id thread id
     * @return OK
     */
    threadDelete(id, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadDelete(_response);
        });
    }
    processThreadDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get thread images
     * @param id thread id
     * @return Success
     */
    threadImages(id, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadImages(_response);
        });
    }
    processThreadImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get thread category
     * @param id thread id
     * @return Success
     */
    threadCategory(id, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/category";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadCategory(_response);
        });
    }
    processThreadCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Pin comment
     * @param id thread id
     * @return OK
     */
    threadPin(id, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadPin(_response);
        });
    }
    processThreadPin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unpin comment
     * @param id thread id
     * @return OK
     */
    threadUnpin(id, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadUnpin(_response);
        });
    }
    processThreadUnpin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Comment not pinned", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Star thread
     * @param id thread id
     * @return OK
     */
    threadStar(id, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadStar(_response);
        });
    }
    processThreadStar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Thread already starred", status, _responseText, _headers, result409);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unstar thread
     * @param id thread id
     * @return OK
     */
    threadUnstar(id, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/unstar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processThreadUnstar(_response);
        });
    }
    processThreadUnstar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Thread not starred", status, _responseText, _headers, result409);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Thread removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Create comment
     * @param id thread id
     * @return Success
     */
    commentCreate(id, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentCreate(_response);
        });
    }
    processCommentCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user muted/banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Recaptcha token invalid, or too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    comment(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processComment(_response);
        });
    }
    processComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Edit comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEdit(id, cid, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentEdit(_response);
        });
    }
    processCommentEdit(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Delete comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentDelete(id, cid, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentDelete(_response);
        });
    }
    processCommentDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get replies
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentReplies(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/replies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentReplies(_response);
        });
    }
    processCommentReplies(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment images.
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentImages(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentImages(_response);
        });
    }
    processCommentImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get votes
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentVotes(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/votes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentVotes(_response);
        });
    }
    processCommentVotes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get emotions
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentEmotions(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentEmotions(_response);
        });
    }
    processCommentEmotions(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get users who expressed the emotion
     * @param id thread id
     * @param cid comment id
     * @param emotion emotion to search for users
     * @return Success
     */
    commentEmotionUsers(id, cid, emotion, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion/{emotion}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        if (emotion === undefined || emotion === null)
            throw new Error("The parameter 'emotion' must be defined.");
        url_ = url_.replace("{emotion}", encodeURIComponent("" + emotion));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentEmotionUsers(_response);
        });
    }
    processCommentEmotionUsers(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Vote on comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentVote(body, id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentVote(_response);
        });
    }
    processCommentVote(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Already voted, or too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Emotion on comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEmotionSet(id, cid, body, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentEmotionSet(_response);
        });
    }
    processCommentEmotionSet(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Delete emotion
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEmotionDelete(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCommentEmotionDelete(_response);
        });
    }
    processCommentEmotionDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Emotion doesn't exist", status, _responseText, _headers, result409);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Logout
     * @return OK
     */
    meLogout(cancelToken) {
        let url_ = this.baseUrl + "/me/logout";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeLogout(_response);
        });
    }
    processMeLogout(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get current logged in session
     * @return Success
     */
    meSessionCurrent(cancelToken) {
        let url_ = this.baseUrl + "/me/session";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeSessionCurrent(_response);
        });
    }
    processMeSessionCurrent(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get active sessions
     * @return Success
     */
    meSessions(cancelToken) {
        let url_ = this.baseUrl + "/me/sessions";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeSessions(_response);
        });
    }
    processMeSessions(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get session by id
     * @param id session id
     * @return Success
     */
    meSession(id, cancelToken) {
        let url_ = this.baseUrl + "/me/sessions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeSession(_response);
        });
    }
    processMeSession(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Session not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Revoke session by id
     * @param id session id
     * @return OK
     */
    meSessionRevoke(id, cancelToken) {
        let url_ = this.baseUrl + "/me/sessions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeSessionRevoke(_response);
        });
    }
    processMeSessionRevoke(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Session not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Failed to revoke an older session", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get notifications
     * @return Success
     */
    meNotifications(cancelToken) {
        let url_ = this.baseUrl + "/me/notifications";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeNotifications(_response);
        });
    }
    processMeNotifications(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Subscribe to notification
     * @return OK
     */
    meNotificationsSubscribe(body, cancelToken) {
        let url_ = this.baseUrl + "/me/notifications/subscribe";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeNotificationsSubscribe(_response);
        });
    }
    processMeNotificationsSubscribe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unsubscribe to notification
     * @return OK
     */
    meNotificationsUnsubscribe(cancelToken) {
        let url_ = this.baseUrl + "/me/notifications/unsubscribe";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeNotificationsUnsubscribe(_response);
        });
    }
    processMeNotificationsUnsubscribe(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get followed users
     * @return Success
     */
    meFollowing(cancelToken) {
        let url_ = this.baseUrl + "/me/following";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeFollowing(_response);
        });
    }
    processMeFollowing(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get blocked users
     * @return Success
     */
    meBlocked(cancelToken) {
        let url_ = this.baseUrl + "/me/blocked";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeBlocked(_response);
        });
    }
    processMeBlocked(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get starred threads
     * @return Success
     */
    meStarred(cancelToken) {
        let url_ = this.baseUrl + "/me/starred";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeStarred(_response);
        });
    }
    processMeStarred(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get votes in thread
     * @param id thread id
     * @return Success
     */
    meVotesThread(id, cancelToken) {
        let url_ = this.baseUrl + "/me/votes/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processMeVotesThread(_response);
        });
    }
    processMeVotesThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get categories
     * @return Success
     */
    categories(cancelToken) {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategories(_response);
        });
    }
    processCategories(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * @return OK
     */
    categoryCreate(body, cancelToken) {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategoryCreate(_response);
        });
    }
    processCategoryCreate(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Category already exists", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get category
     * @param id category id
     * @return Success
     */
    category(id, cancelToken) {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategory(_response);
        });
    }
    processCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Edit a category
     * @param id category id
     * @return OK
     */
    categoryEdit(id, body, cancelToken) {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategoryEdit(_response);
        });
    }
    processCategoryEdit(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Delete a category
     * @param id category id
     * @return OK
     */
    categoryDelete(id, cancelToken) {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategoryDelete(_response);
        });
    }
    processCategoryDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads in a category
     * @param id category id
     * @param sort (optional) Sort threads by latest or viral
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    categoryThreads(id, sort, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/categories/{id}/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCategoryThreads(_response);
        });
    }
    processCategoryThreads(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get user profile
     * @param id user id
     * @return Success
     */
    userProfile(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserProfile(_response);
        });
    }
    processUserProfile(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Edit user info
     * @param id user id
     * @return Success
     */
    userEdit(id, body, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserEdit(_response);
        });
    }
    processUserEdit(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Name already taken", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get user name
     * @param id user id
     * @return Success
     */
    userName(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/name";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserName(_response);
        });
    }
    processUserName(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get user avatar
     * @param id user id
     * @return Success
     */
    userAvatar(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                Accept: "image/png",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserAvatar(_response);
        });
    }
    processUserAvatar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers["content-disposition"]
                : undefined;
            let fileNameMatch = contentDisposition
                ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
                : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1
                ? fileNameMatch[3] || fileNameMatch[2]
                : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            }
            else {
                fileNameMatch = contentDisposition
                    ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                    : undefined;
                fileName =
                    fileNameMatch && fileNameMatch.length > 1
                        ? fileNameMatch[1]
                        : undefined;
            }
            return Promise.resolve({
                fileName: fileName,
                status: status,
                data: new Blob([response.data], {
                    type: response.headers["content-type"],
                }),
                headers: _headers,
            });
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User or avatar not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Upload avatar
     * @param id user id
     * @param avatar (optional) Avatar image. Must be smaller than 2MB. Png, jpg, jpeg, jfif, svg, gif, webp are supported.
     * @return OK
     */
    userAvatarUpload(id, avatar, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = new FormData();
        if (avatar === null || avatar === undefined)
            throw new Error("The parameter 'avatar' cannot be null.");
        else
            content_.append("avatar", avatar.data, avatar.fileName ? avatar.fileName : "avatar");
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserAvatarUpload(_response);
        });
    }
    processUserAvatarUpload(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 413) {
            const _responseText = response.data;
            let result413 = null;
            let resultData413 = _responseText;
            result413 = JSON.parse(resultData413);
            return throwException("File too large", status, _responseText, _headers, result413);
        }
        else if (status === 415) {
            const _responseText = response.data;
            let result415 = null;
            let resultData415 = _responseText;
            result415 = JSON.parse(resultData415);
            return throwException("File type not supported", status, _responseText, _headers, result415);
        }
        else if (status === 422) {
            const _responseText = response.data;
            let result422 = null;
            let resultData422 = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException("File unprocessable", status, _responseText, _headers, result422);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Delete avatar
     * @param id user id
     * @return OK
     */
    userAvatarDelete(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserAvatarDelete(_response);
        });
    }
    processUserAvatarDelete(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Avatar not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads created by a user
     * @param id user id
     * @param sort (optional) Sort threads by created or lastcomment
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    userThreads(id, sort, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserThreads(_response);
        });
    }
    processUserThreads(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Follow user
     * @param id user id
     * @return OK
     */
    userFollow(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/follow";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserFollow(_response);
        });
    }
    processUserFollow(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User already followed", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unfollow user
     * @param id user id
     * @return OK
     */
    userUnfollow(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/unfollow";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserUnfollow(_response);
        });
    }
    processUserUnfollow(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User not followed", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Block user
     * @param id user id
     * @return OK
     */
    userBlock(id, body, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/block";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserBlock(_response);
        });
    }
    processUserBlock(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User already blocked", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unblock user
     * @param id user id
     * @return OK
     */
    userUnblock(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/unblock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserUnblock(_response);
        });
    }
    processUserUnblock(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User not blocked", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Mute user
     * @param id user id
     * @return OK
     */
    userMute(id, body, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/mute";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserMute(_response);
        });
    }
    processUserMute(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User is an admin. Cannot mute.", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unmute user
     * @param id user id
     * @return OK
     */
    userUnmute(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/unmute";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserUnmute(_response);
        });
    }
    processUserUnmute(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User not muted", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Ban user
     * @param id user id
     * @return OK
     */
    userBan(id, body, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/ban";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserBan(_response);
        });
    }
    processUserBan(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User is an admin. Cannot ban.", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unban user
     * @param id user id
     * @return OK
     */
    userUnban(id, cancelToken) {
        let url_ = this.baseUrl + "/users/{id}/unban";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserUnban(_response);
        });
    }
    processUserUnban(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("User not banned", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Login
     * @return Success
     */
    usersLogin(body, cancelToken) {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersLogin(_response);
        });
    }
    processUsersLogin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Login failed", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Email verification needed", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Register
     * @return Success, verification email sent.
     */
    usersRegister(body, cancelToken) {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersRegister(_response);
        });
    }
    processUsersRegister(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Bad request / registration disabled / invalid invite code", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException("Email or username already in use", status, _responseText, _headers, result409);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Verify email
     * @return Success
     */
    usersVerify(body, cancelToken) {
        let url_ = this.baseUrl + "/users/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersVerify(_response);
        });
    }
    processUsersVerify(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException("Code incorrect or expired, or email not found", status, _responseText, _headers, result401);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Resend verification email
     * @return Success
     */
    usersResend(body, cancelToken) {
        let url_ = this.baseUrl + "/users/resend";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersResend(_response);
        });
    }
    processUsersResend(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("Email not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Recaptcha token invalid, or too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Forgot password
     * @return Success
     */
    usersForgot(body, cancelToken) {
        let url_ = this.baseUrl + "/users/forgot";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersForgot(_response);
        });
    }
    processUsersForgot(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Recaptcha token invalid, or too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Reset password
     * @return Success
     */
    usersReset(body, cancelToken) {
        let url_ = this.baseUrl + "/users/reset";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUsersReset(_response);
        });
    }
    processUsersReset(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException("Forbidden: permission denied or user banned by an admin", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status === 502) {
            const _responseText = response.data;
            let result502 = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException("Bad gateway", status, _responseText, _headers, result502);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
}
exports.Client = Client;
function isFollowedUser(object) {
    return object && object[""] === "FollowedUser";
}
exports.isFollowedUser = isFollowedUser;
function isBlockedUser(object) {
    return object && object[""] === "BlockedUser";
}
exports.isBlockedUser = isBlockedUser;
function isAnonymous6(object) {
    return object && object[""] === "Anonymous6";
}
exports.isAnonymous6 = isAnonymous6;
function isQuote(object) {
    return object && object[""] === "Quote";
}
exports.isQuote = isQuote;
function isConversation(object) {
    return object && object[""] === "Conversation";
}
exports.isConversation = isConversation;
class ApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isApiException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isApiException(obj) {
        return obj.isApiException === true;
    }
}
exports.ApiException = ApiException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
function isAxiosError(obj) {
    return obj && obj.isAxiosError === true;
}
//# sourceMappingURL=index.js.map