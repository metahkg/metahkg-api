//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiException = exports.Name = exports.Conversation = exports.UserSex = exports.OKResponse = exports.Anonymous6 = exports.Anonymous5 = exports.Anonymous4 = exports.Anonymous3 = exports.Anonymous2 = exports.Anonymous = exports.Sort3 = exports.Mode = exports.Sort2 = exports.Body10 = exports.Body9 = exports.Body8 = exports.Body7 = exports.Body6 = exports.Body5 = exports.Nameonly = exports.Id = exports.Body4 = exports.Body3 = exports.Body2 = exports.Body = exports.Sort = exports.ThreadMeta = exports.Thread = exports.Comment = exports.CommentC = exports.RemovedComment = exports.Image = exports.Category = exports.User = exports.Vote = exports.ErrorDto = exports.Token = exports.OK = exports.Client = void 0;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
const axios_1 = __importDefault(require("axios"));
class Client {
    constructor(baseUrl, instance) {
        this.jsonParseReviver = undefined;
        this.instance = instance ? instance : axios_1.default.create();
        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : "https://metahkg.org/api";
    }
    /**
     * Get thread
     * @param id thread id
     * @param page (optional) Page number. Ignored if start and end both specified.
     * @param limit (optional) Limit of comments per page.
     * @param sort (optional) Sort comments by score / time / latest. "time" means sorting acsendingly by created time, "latest" means desceningly, "score" means sorting descendingly by `upvotes - downvotes`
     * @param start (optional) Starting from comment id. If end is specified but start is not, start default to `(page - 1) * limit + 1`
     * @param end (optional) Ending at comment id. Must be greater or equal to start. If start is specified but end is not, end defaults to `page * limit`
     * @return Success
     */
    getThread(id, page, limit, sort, start, end, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetThread(_response);
        });
    }
    processGetThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Thread.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 403) {
            const _responseText = response.data;
            let result403 = null;
            let resultData403 = _responseText;
            result403 = ErrorDto.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Check if a thread exists
     * @param id thread id
     * @return OK
     */
    checkThread(id, cancelToken) {
        let url_ = this.baseUrl + "/thread/check?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCheckThread(_response);
        });
    }
    processCheckThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get thread images
     * @param id thread id
     * @return Success
     */
    getThreadImages(id, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetThreadImages(_response);
        });
    }
    processGetThreadImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Image.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Create thread
     * @param body (optional)
     * @return Success
     */
    createThread(body, cancelToken) {
        let url_ = this.baseUrl + "/thread/create";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCreateThread(_response);
        });
    }
    processCreateThread(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Anonymous.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("Recaptcha token invalid", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    getComment(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetComment(_response);
        });
    }
    processGetComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Comment.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get replies
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    getCommentReplies(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/replies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetCommentReplies(_response);
        });
    }
    processGetCommentReplies(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Comment.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = ErrorDto.fromJS(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get comment images.
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    getCommentImages(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetCommentImages(_response);
        });
    }
    processGetCommentImages(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Image.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = ErrorDto.fromJS(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Create comment
     * @param id thread id
     * @param body (optional)
     * @return Success
     */
    createComment(id, body, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/create";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processCreateComment(_response);
        });
    }
    processCreateComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Anonymous2.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("Recaptcha token invalid", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Vote on comment
     * @param body (optional)
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    vote(id, cid, body, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processVote(_response);
        });
    }
    processVote(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = ErrorDto.fromJS(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("User has already voted", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Pin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    pinComment(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processPinComment(_response);
        });
    }
    processPinComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 410) {
            const _responseText = response.data;
            let result410 = null;
            let resultData410 = _responseText;
            result410 = ErrorDto.fromJS(resultData410);
            return throwException("Comment removed", status, _responseText, _headers, result410);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unpin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    unpinComment(id, cid, cancelToken) {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/unpin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "PUT",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUnpinComment(_response);
        });
    }
    processUnpinComment(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread or comment not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("Comment not pinned", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get status
     * @return Success
     */
    getStatus(cancelToken) {
        let url_ = this.baseUrl + "/me/status";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetStatus(_response);
        });
    }
    processGetStatus(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : null;
            return Promise.resolve(result200);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get blocked users
     * @return Success
     */
    getBlockedUsers(cancelToken) {
        let url_ = this.baseUrl + "/me/blocked";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetBlockedUsers(_response);
        });
    }
    processGetBlockedUsers(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get votes
     * @param id thread id
     * @return Success
     */
    getVotes(id, cancelToken) {
        let url_ = this.baseUrl + "/me/votes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetVotes(_response);
        });
    }
    processGetVotes(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Thread not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Block user
     * @return OK
     */
    blockUser(cancelToken) {
        let url_ = this.baseUrl + "/me/block";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processBlockUser(_response);
        });
    }
    processBlockUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("User already blocked", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Unblock user
     * @return OK
     */
    unblockUser(cancelToken) {
        let url_ = this.baseUrl + "/me/unblock";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUnblockUser(_response);
        });
    }
    processUnblockUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("User not blocked", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Set avatar
     * @param avatar (optional) Avatar image. Must be smaller than 2MB. Png, jpg, jpeg, jfif, svg, gif, webp are supported.
     * @return OK
     */
    setAvatar(avatar, cancelToken) {
        let url_ = this.baseUrl + "/me/avatar";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = new FormData();
        if (avatar === null || avatar === undefined)
            throw new Error("The parameter 'avatar' cannot be null.");
        else
            content_.append("avatar", avatar.data, avatar.fileName ? avatar.fileName : "avatar");
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processSetAvatar(_response);
        });
    }
    processSetAvatar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 413) {
            const _responseText = response.data;
            let result413 = null;
            let resultData413 = _responseText;
            result413 = ErrorDto.fromJS(resultData413);
            return throwException("File too large", status, _responseText, _headers, result413);
        }
        else if (status === 415) {
            const _responseText = response.data;
            let result415 = null;
            let resultData415 = _responseText;
            result415 = ErrorDto.fromJS(resultData415);
            return throwException("File type not supported", status, _responseText, _headers, result415);
        }
        else if (status === 422) {
            const _responseText = response.data;
            let result422 = null;
            let resultData422 = _responseText;
            result422 = ErrorDto.fromJS(resultData422);
            return throwException("File unprocessable", status, _responseText, _headers, result422);
        }
        else if (status === 500) {
            const _responseText = response.data;
            let result500 = null;
            let resultData500 = _responseText;
            result500 = ErrorDto.fromJS(resultData500);
            return throwException("Internal server error", status, _responseText, _headers, result500);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Rename
     * @param body (optional)
     * @return Success
     */
    renameUser(body, cancelToken) {
        let url_ = this.baseUrl + "/me/rename";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processRenameUser(_response);
        });
    }
    processRenameUser(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : null;
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("Name already taken", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get categories
     * @return Success
     */
    getCategories(cancelToken) {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetCategories(_response);
        });
    }
    processGetCategories(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Category.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get category
     * @param id category id, or `bytid<thread id>`
     * @return Success
     */
    getCategory(id, cancelToken) {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetCategory(_response);
        });
    }
    processGetCategory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Category.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get user profile
     * @param id user id
     * @param nameonly (optional) return user name only
     * @return Success
     */
    userProfile(id, nameonly, cancelToken) {
        let url_ = this.baseUrl + "/users/profile/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (nameonly === null)
            throw new Error("The parameter 'nameonly' cannot be null.");
        else if (nameonly !== undefined)
            url_ += "nameonly=" + encodeURIComponent("" + nameonly) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserProfile(_response);
        });
    }
    processUserProfile(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : null;
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get user avatar
     * @param id user id
     * @return Success
     */
    userAvatar(id, cancelToken) {
        let url_ = this.baseUrl + "/users/avatars/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                Accept: "image/png",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processUserAvatar(_response);
        });
    }
    processUserAvatar(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers["content-disposition"]
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({
                fileName: fileName,
                status: status,
                data: new Blob([response.data], {
                    type: response.headers["content-type"],
                }),
                headers: _headers,
            });
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Login
     * @param body (optional)
     * @return Success
     */
    login(body, cancelToken) {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processLogin(_response);
        });
    }
    processLogin(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Login failed", status, _responseText, _headers, result401);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("Email verification needed", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Register
     * @param body (optional)
     * @return Success, verification email sent.
     */
    register(body, cancelToken) {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processRegister(_response);
        });
    }
    processRegister(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            return throwException("Bad request / registration disabled / invalid invite code", status, _responseText, _headers);
        }
        else if (status === 409) {
            const _responseText = response.data;
            let result409 = null;
            let resultData409 = _responseText;
            result409 = ErrorDto.fromJS(resultData409);
            return throwException("Email or username already in use", status, _responseText, _headers, result409);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Verify email
     * @param body (optional)
     * @return Success
     */
    verify(body, cancelToken) {
        let url_ = this.baseUrl + "/users/verify";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processVerify(_response);
        });
    }
    processVerify(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 401) {
            const _responseText = response.data;
            let result401 = null;
            let resultData401 = _responseText;
            result401 = ErrorDto.fromJS(resultData401);
            return throwException("Code incorrect or expired / email not found", status, _responseText, _headers, result401);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Resend verification email
     * @param body (optional)
     * @return Success
     */
    resend(body, cancelToken) {
        let url_ = this.baseUrl + "/users/resend";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processResend(_response);
        });
    }
    processResend(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Email not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("Too many requests / ReCAPTCHA token invalid", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Forgot password
     * @param body (optional)
     * @return Success
     */
    forgot(body, cancelToken) {
        let url_ = this.baseUrl + "/users/forgot";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processForgot(_response);
        });
    }
    processForgot(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = OK.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("Too many requests / ReCAPTCHA token invalid", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Reset password
     * @param body (optional)
     * @return Success
     */
    reset(body, cancelToken) {
        let url_ = this.baseUrl + "/users/reset";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(body);
        let options_ = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processReset(_response);
        });
    }
    processReset(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            result200 = Token.fromJS(resultData200);
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status === 429) {
            const _responseText = response.data;
            let result429 = null;
            let resultData429 = _responseText;
            result429 = ErrorDto.fromJS(resultData429);
            return throwException("Too many requests", status, _responseText, _headers, result429);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads in a category
     * @param category category id
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    getMenu(category, sort, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/menu/{category}?";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetMenu(_response);
        });
    }
    processGetMenu(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThreadMeta.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("Category not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Search threads
     * @param q Search query
     * @param mode (optional) Search mode. `0: title` or `1: op`
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    searchMenu(q, mode, sort, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/menu/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mode === null)
            throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processSearchMenu(_response);
        });
    }
    processSearchMenu(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThreadMeta.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads from a user
     * @param id user id
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    getHistory(id, page, limit, cancelToken) {
        let url_ = this.baseUrl + "/menu/history/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetHistory(_response);
        });
    }
    processGetHistory(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThreadMeta.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status === 404) {
            const _responseText = response.data;
            let result404 = null;
            let resultData404 = _responseText;
            result404 = ErrorDto.fromJS(resultData404);
            return throwException("User not found", status, _responseText, _headers, result404);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
    /**
     * Get threads
     * @param threads Thread ids
     * @return Success
     */
    getThreads(threads, cancelToken) {
        let url_ = this.baseUrl + "/menu/threads?";
        if (threads === undefined || threads === null)
            throw new Error("The parameter 'threads' must be defined and cannot be null.");
        else
            threads &&
                threads.forEach((item) => {
                    url_ += "threads=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };
        return this.instance
            .request(options_)
            .catch((_error) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            }
            else {
                throw _error;
            }
        })
            .then((_response) => {
            return this.processGetThreads(_response);
        });
    }
    processGetThreads(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200 = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ThreadMeta.fromJS(item));
            }
            else {
                result200 = null;
            }
            return Promise.resolve(result200);
        }
        else if (status === 400) {
            const _responseText = response.data;
            let result400 = null;
            let resultData400 = _responseText;
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("Invalid request", status, _responseText, _headers, result400);
        }
        else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve(null);
    }
}
exports.Client = Client;
class OK {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.response = _data["response"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new OK();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["response"] = this.response;
        return data;
    }
}
exports.OK = OK;
class Token {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.token = _data["token"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["token"] = this.token;
        return data;
    }
}
exports.Token = Token;
class ErrorDto {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.error = _data["error"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["error"] = this.error;
        return data;
    }
}
exports.ErrorDto = ErrorDto;
/** Vote. "U" means upvote. "D" means downvote. */
var Vote;
(function (Vote) {
    Vote["U"] = "U";
    Vote["D"] = "D";
})(Vote = exports.Vote || (exports.Vote = {}));
class User {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sex = _data["sex"];
            this.createdAt = _data["createdAt"]
                ? new Date(_data["createdAt"].toString())
                : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sex"] = this.sex;
        data["createdAt"] = this.createdAt
            ? this.createdAt.toISOString()
            : undefined;
        return data;
    }
}
exports.User = User;
class Category {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}
exports.Category = Category;
class Image {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.cid = _data["cid"];
            this.src = _data["src"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["cid"] = this.cid;
        data["src"] = this.src;
        return data;
    }
}
exports.Image = Image;
class RemovedComment {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.removed = _data["removed"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new RemovedComment();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["removed"] = this.removed;
        return data;
    }
}
exports.RemovedComment = RemovedComment;
/** Comment object with constants only (without upvotes, downvotes and replies) */
class CommentC {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.images = [];
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.comment = _data["comment"];
            this.text = _data["text"];
            if (Array.isArray(_data["images"])) {
                this.images = [];
                for (let item of _data["images"])
                    this.images.push(item);
            }
            this.createdAt = _data["createdAt"]
                ? new Date(_data["createdAt"].toString())
                : undefined;
            this.slink = _data["slink"];
            this.quote = _data["quote"]
                ? CommentC.fromJS(_data["quote"])
                : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new CommentC();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : undefined;
        data["comment"] = this.comment;
        data["text"] = this.text;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["createdAt"] = this.createdAt
            ? this.createdAt.toISOString()
            : undefined;
        data["slink"] = this.slink;
        data["quote"] = this.quote ? this.quote.toJSON() : undefined;
        return data;
    }
}
exports.CommentC = CommentC;
/** Comment object */
class Comment extends CommentC {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.d = _data["D"];
            this.u = _data["U"];
            if (Array.isArray(_data["replies"])) {
                this.replies = [];
                for (let item of _data["replies"])
                    this.replies.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["D"] = this.d;
        data["U"] = this.u;
        if (Array.isArray(this.replies)) {
            data["replies"] = [];
            for (let item of this.replies)
                data["replies"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}
exports.Comment = Comment;
class Thread {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.op = new User();
            this.conversation = [];
            this.images = [];
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.category = _data["category"];
            this.op = _data["op"] ? User.fromJS(_data["op"]) : new User();
            this.c = _data["c"];
            if (Array.isArray(_data["conversation"])) {
                this.conversation = [];
                for (let item of _data["conversation"])
                    this.conversation.push(item);
            }
            this.score = _data["score"];
            if (Array.isArray(_data["images"])) {
                this.images = [];
                for (let item of _data["images"])
                    this.images.push(Image.fromJS(item));
            }
            this.createdAt = _data["createdAt"]
                ? new Date(_data["createdAt"].toString())
                : undefined;
            this.lastModified = _data["lastModified"]
                ? new Date(_data["lastModified"].toString())
                : undefined;
            this.slink = _data["slink"];
            this.pin = _data["pin"] ? CommentC.fromJS(_data["pin"]) : undefined;
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Thread();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["category"] = this.category;
        data["op"] = this.op ? this.op.toJSON() : undefined;
        data["c"] = this.c;
        if (Array.isArray(this.conversation)) {
            data["conversation"] = [];
            for (let item of this.conversation)
                data["conversation"].push(item);
        }
        data["score"] = this.score;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["createdAt"] = this.createdAt
            ? this.createdAt.toISOString()
            : undefined;
        data["lastModified"] = this.lastModified
            ? this.lastModified.toISOString()
            : undefined;
        data["slink"] = this.slink;
        data["pin"] = this.pin ? this.pin.toJSON() : undefined;
        return data;
    }
}
exports.Thread = Thread;
/** Thread metadata (no comments, images and pinned comment) */
class ThreadMeta {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.op = new User();
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.category = _data["category"];
            this.op = _data["op"] ? User.fromJS(_data["op"]) : new User();
            this.c = _data["c"];
            this.score = _data["score"];
            this.createdAt = _data["createdAt"]
                ? new Date(_data["createdAt"].toString())
                : undefined;
            this.lastModified = _data["lastModified"]
                ? new Date(_data["lastModified"].toString())
                : undefined;
            this.slink = _data["slink"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new ThreadMeta();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["category"] = this.category;
        data["op"] = this.op ? this.op.toJSON() : undefined;
        data["c"] = this.c;
        data["score"] = this.score;
        data["createdAt"] = this.createdAt
            ? this.createdAt.toISOString()
            : undefined;
        data["lastModified"] = this.lastModified
            ? this.lastModified.toISOString()
            : undefined;
        data["slink"] = this.slink;
        return data;
    }
}
exports.ThreadMeta = ThreadMeta;
var Sort;
(function (Sort) {
    Sort["Score"] = "score";
    Sort["Time"] = "time";
    Sort["Latest"] = "latest";
})(Sort = exports.Sort || (exports.Sort = {}));
class Body {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.rtoken = _data["rtoken"];
            this.category = _data["category"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["rtoken"] = this.rtoken;
        data["category"] = this.category;
        return data;
    }
}
exports.Body = Body;
class Body2 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.comment = _data["comment"];
            this.rtoken = _data["rtoken"];
            this.quote = _data["quote"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["comment"] = this.comment;
        data["rtoken"] = this.rtoken;
        data["quote"] = this.quote;
        return data;
    }
}
exports.Body2 = Body2;
class Body3 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.vote = _data["vote"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body3();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["vote"] = this.vote;
        return data;
    }
}
exports.Body3 = Body3;
class Body4 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body4();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        return data;
    }
}
exports.Body4 = Body4;
class Id {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) { }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Id();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Id = Id;
var Nameonly;
(function (Nameonly) {
    Nameonly[Nameonly["_0"] = 0] = "_0";
    Nameonly[Nameonly["_1"] = 1] = "_1";
})(Nameonly = exports.Nameonly || (exports.Nameonly = {}));
class Body5 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"];
            this.pwd = _data["pwd"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body5();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["pwd"] = this.pwd;
        return data;
    }
}
exports.Body5 = Body5;
class Body6 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.pwd = _data["pwd"];
            this.sex = _data["sex"];
            this.rtoken = _data["rtoken"];
            this.inviteCode = _data["inviteCode"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body6();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["pwd"] = this.pwd;
        data["sex"] = this.sex;
        data["rtoken"] = this.rtoken;
        data["inviteCode"] = this.inviteCode;
        return data;
    }
}
exports.Body6 = Body6;
class Body7 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body7();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        return data;
    }
}
exports.Body7 = Body7;
class Body8 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.email = _data["email"];
            this.rtoken = _data["rtoken"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body8();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["email"] = this.email;
        data["rtoken"] = this.rtoken;
        return data;
    }
}
exports.Body8 = Body8;
class Body9 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.email = _data["email"];
            this.rtoken = _data["rtoken"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body9();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["email"] = this.email;
        data["rtoken"] = this.rtoken;
        return data;
    }
}
exports.Body9 = Body9;
class Body10 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.pwd = _data["pwd"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Body10();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["pwd"] = this.pwd;
        return data;
    }
}
exports.Body10 = Body10;
var Sort2;
(function (Sort2) {
    Sort2[Sort2["_0"] = 0] = "_0";
    Sort2[Sort2["_1"] = 1] = "_1";
})(Sort2 = exports.Sort2 || (exports.Sort2 = {}));
var Mode;
(function (Mode) {
    Mode[Mode["_0"] = 0] = "_0";
    Mode[Mode["_1"] = 1] = "_1";
})(Mode = exports.Mode || (exports.Mode = {}));
var Sort3;
(function (Sort3) {
    Sort3[Sort3["_0"] = 0] = "_0";
    Sort3[Sort3["_1"] = 1] = "_1";
})(Sort3 = exports.Sort3 || (exports.Sort3 = {}));
class Anonymous {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        return data;
    }
}
exports.Anonymous = Anonymous;
class Anonymous2 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.id = _data["id"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        return data;
    }
}
exports.Anonymous2 = Anonymous2;
class Anonymous3 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) { }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Anonymous3 = Anonymous3;
class Anonymous4 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) {
        if (_data) {
            this.cid = _data["cid"];
            this.vote = _data["vote"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["cid"] = this.cid;
        data["vote"] = this.vote;
        return data;
    }
}
exports.Anonymous4 = Anonymous4;
class Anonymous5 extends OK {
    constructor(data) {
        super(data);
    }
    init(_data) {
        super.init(_data);
        if (_data) {
            this.token = _data["token"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["token"] = this.token;
        super.toJSON(data);
        return data;
    }
}
exports.Anonymous5 = Anonymous5;
class Anonymous6 {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) { }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Anonymous6 = Anonymous6;
var OKResponse;
(function (OKResponse) {
    OKResponse["Ok"] = "ok";
})(OKResponse = exports.OKResponse || (exports.OKResponse = {}));
var UserSex;
(function (UserSex) {
    UserSex["M"] = "M";
    UserSex["F"] = "F";
})(UserSex = exports.UserSex || (exports.UserSex = {}));
class Conversation {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) { }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Conversation();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Conversation = Conversation;
class Name {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(_data) { }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Name();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Name = Name;
class ApiException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isApiException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isApiException(obj) {
        return obj.isApiException === true;
    }
}
exports.ApiException = ApiException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
function isAxiosError(obj) {
    return obj && obj.isAxiosError === true;
}
//# sourceMappingURL=index.js.map