//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
        undefined;

    constructor(
        baseUrl?: string,
        http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
    ) {
        this.http = http ? http : (window as any);
        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : "https://dev.metahkg.org/api";
    }

    /**
     * Get thread
     * @param id thread id
     * @param page (optional) Page number. Ignored if start and end both specified.
     * @param limit (optional) Limit of comments per page.
     * @param sort (optional) Sort comments by score / time / latest. "time" means sorting acsendingly by created time, "latest" means desceningly, "score" means sorting descendingly by `upvotes - downvotes`
     * @param start (optional) Starting from comment id. If end is specified but start is not, start default to `(page - 1) * limit + 1`
     * @param end (optional) Ending at comment id. Must be greater or equal to start. If start is specified but end is not, end defaults to `page * limit`
     * @return Success
     */
    thread(
        id: number,
        page?: number,
        limit?: number,
        sort?: Sort,
        start?: number,
        end?: number
    ): Promise<Thread> {
        let url_ = this.baseUrl + "/thread/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (start === null) throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null) throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined) url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThread(_response);
        });
    }

    protected processThread(response: Response): Promise<Thread> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Thread);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
                let result403: any = null;
                result403 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Forbidden",
                    status,
                    _responseText,
                    _headers,
                    result403
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Thread>(null as any);
    }

    /**
     * Check if a thread exists
     * @param id thread id
     * @return OK
     */
    threadCheck(id: number): Promise<OK> {
        let url_ = this.baseUrl + "/thread/check?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThreadCheck(_response);
        });
    }

    protected processThreadCheck(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get thread images
     * @param id thread id
     * @return Success
     */
    threadImages(id: number): Promise<Image[]> {
        let url_ = this.baseUrl + "/thread/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThreadImages(_response);
        });
    }

    protected processThreadImages(response: Response): Promise<Image[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Image[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Image[]>(null as any);
    }

    /**
     * Create thread
     * @param body (optional)
     * @return Success
     */
    threadCreate(body?: Body): Promise<Anonymous> {
        let url_ = this.baseUrl + "/thread/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processThreadCreate(_response);
        });
    }

    protected processThreadCreate(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Anonymous);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Category not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Recaptcha token invalid",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * Get comment
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    comment(id: number, cid: number): Promise<Comment> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComment(_response);
        });
    }

    protected processComment(response: Response): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Comment);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Comment>(null as any);
    }

    /**
     * Get replies
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentReplies(id: number, cid: number): Promise<Comment[]> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/replies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentReplies(_response);
        });
    }

    protected processCommentReplies(response: Response): Promise<Comment[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Comment[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410: any = null;
                result410 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Comment removed",
                    status,
                    _responseText,
                    _headers,
                    result410
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Comment[]>(null as any);
    }

    /**
     * Get comment images.
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentImages(id: number, cid: number): Promise<Image[]> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentImages(_response);
        });
    }

    protected processCommentImages(response: Response): Promise<Image[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Image[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410: any = null;
                result410 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Comment removed",
                    status,
                    _responseText,
                    _headers,
                    result410
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Image[]>(null as any);
    }

    /**
     * Create comment
     * @param id thread id
     * @param body (optional)
     * @return Success
     */
    commentCreate(id: number, body?: Body2): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/thread/{id}/comment/create";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentCreate(_response);
        });
    }

    protected processCommentCreate(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous2);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Recaptcha token invalid",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous2>(null as any);
    }

    /**
     * Vote on comment
     * @param body (optional)
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentVote(id: number, cid: number, body?: Body3): Promise<OK> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentVote(_response);
        });
    }

    protected processCommentVote(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410: any = null;
                result410 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Comment removed",
                    status,
                    _responseText,
                    _headers,
                    result410
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User has already voted",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Pin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentPin(id: number, cid: number): Promise<OK> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentPin(_response);
        });
    }

    protected processCommentPin(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
                let result410: any = null;
                result410 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Comment removed",
                    status,
                    _responseText,
                    _headers,
                    result410
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unpin comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentUnpin(id: number, cid: number): Promise<OK> {
        let url_ = this.baseUrl + "/thread/{id}/comment/{cid}/unpin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCommentUnpin(_response);
        });
    }

    protected processCommentUnpin(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread or comment not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Comment not pinned",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get status
     * @return Success
     */
    meStatus(): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/me/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeStatus(_response);
        });
    }

    protected processMeStatus(response: Response): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous3);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous3>(null as any);
    }

    /**
     * Get blocked users
     * @return Success
     */
    meBlocked(): Promise<User[]> {
        let url_ = this.baseUrl + "/me/blocked";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeBlocked(_response);
        });
    }

    protected processMeBlocked(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as User[]);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * Get votes
     * @param id thread id
     * @return Success
     */
    meVotes(id: number): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/me/votes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeVotes(_response);
        });
    }

    protected processMeVotes(response: Response): Promise<Anonymous4[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous4[]);
                return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Thread not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous4[]>(null as any);
    }

    /**
     * Block user
     * @return OK
     */
    meBlock(): Promise<OK> {
        let url_ = this.baseUrl + "/me/block";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeBlock(_response);
        });
    }

    protected processMeBlock(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User already blocked",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unblock user
     * @return OK
     */
    meUnblock(): Promise<OK> {
        let url_ = this.baseUrl + "/me/unblock";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeUnblock(_response);
        });
    }

    protected processMeUnblock(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not blocked",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Set avatar
     * @param avatar (optional) Avatar image. Must be smaller than 2MB. Png, jpg, jpeg, jfif, svg, gif, webp are supported.
     * @return OK
     */
    meAvatar(avatar?: FileParameter): Promise<OK> {
        let url_ = this.baseUrl + "/me/avatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (avatar === null || avatar === undefined)
            throw new Error("The parameter 'avatar' cannot be null.");
        else
            content_.append(
                "avatar",
                avatar.data,
                avatar.fileName ? avatar.fileName : "avatar"
            );

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeAvatar(_response);
        });
    }

    protected processMeAvatar(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
                let result413: any = null;
                result413 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "File too large",
                    status,
                    _responseText,
                    _headers,
                    result413
                );
            });
        } else if (status === 415) {
            return response.text().then((_responseText) => {
                let result415: any = null;
                result415 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "File type not supported",
                    status,
                    _responseText,
                    _headers,
                    result415
                );
            });
        } else if (status === 422) {
            return response.text().then((_responseText) => {
                let result422: any = null;
                result422 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "File unprocessable",
                    status,
                    _responseText,
                    _headers,
                    result422
                );
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
                let result500: any = null;
                result500 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Internal server error",
                    status,
                    _responseText,
                    _headers,
                    result500
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Rename
     * @param body (optional)
     * @return Success
     */
    meRename(body?: Body4): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/me/rename";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMeRename(_response);
        });
    }

    protected processMeRename(response: Response): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous5);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Unauthorized",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Name already taken",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous5>(null as any);
    }

    /**
     * Get categories
     * @return Success
     */
    categories(): Promise<Category[]> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategories(_response);
        });
    }

    protected processCategories(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Category[]);
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * Get category
     * @param id category id, or `bytid<thread id>`
     * @return Success
     */
    category(id: Id): Promise<Category> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCategory(_response);
        });
    }

    protected processCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Category);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Category not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Get user profile
     * @param id user id
     * @return Success
     */
    usersProfile(id: number): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersProfile(_response);
        });
    }

    protected processUsersProfile(response: Response): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous6);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    /**
     * Get user name
     * @param id user id
     * @return Success
     */
    usersProfileName(id: number): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/users/{id}/name";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersProfileName(_response);
        });
    }

    protected processUsersProfileName(response: Response): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as Anonymous7);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Anonymous7>(null as any);
    }

    /**
     * Get user avatar
     * @param id user id
     * @return Success
     */
    usersProfileAvatar(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "image/png",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersProfileAvatar(_response);
        });
    }

    protected processUsersProfileAvatar(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then((blob) => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers,
                };
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Login
     * @param body (optional)
     * @return Success
     */
    usersLogin(body?: Body5): Promise<Token> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersLogin(_response);
        });
    }

    protected processUsersLogin(response: Response): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Token);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Login failed",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Email verification needed",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Register
     * @param body (optional)
     * @return Success, verification email sent.
     */
    usersRegister(body?: Body6): Promise<OK> {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersRegister(_response);
        });
    }

    protected processUsersRegister(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                return throwException(
                    "Bad request / registration disabled / invalid invite code",
                    status,
                    _responseText,
                    _headers
                );
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
                let result409: any = null;
                result409 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Email or username already in use",
                    status,
                    _responseText,
                    _headers,
                    result409
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Verify email
     * @param body (optional)
     * @return Success
     */
    usersVerify(body?: Body7): Promise<Token> {
        let url_ = this.baseUrl + "/users/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersVerify(_response);
        });
    }

    protected processUsersVerify(response: Response): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Token);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
                let result401: any = null;
                result401 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Code incorrect or expired / email not found",
                    status,
                    _responseText,
                    _headers,
                    result401
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Resend verification email
     * @param body (optional)
     * @return Success
     */
    usersResend(body?: Body8): Promise<OK> {
        let url_ = this.baseUrl + "/users/resend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersResend(_response);
        });
    }

    protected processUsersResend(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Email not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Too many requests / ReCAPTCHA token invalid",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Forgot password
     * @param body (optional)
     * @return Success
     */
    usersForgot(body?: Body9): Promise<OK> {
        let url_ = this.baseUrl + "/users/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersForgot(_response);
        });
    }

    protected processUsersForgot(response: Response): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as OK);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Too many requests / ReCAPTCHA token invalid",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Reset password
     * @param body (optional)
     * @return Success
     */
    usersReset(body?: Body10): Promise<Token> {
        let url_ = this.baseUrl + "/users/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsersReset(_response);
        });
    }

    protected processUsersReset(response: Response): Promise<Token> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as Token);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
                let result429: any = null;
                result429 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Too many requests",
                    status,
                    _responseText,
                    _headers,
                    result429
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Token>(null as any);
    }

    /**
     * Get threads in a category
     * @param category category id
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuCategory(
        category: number,
        sort?: Sort2,
        page?: number,
        limit?: number
    ): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/menu/{category}?";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMenuCategory(_response);
        });
    }

    protected processMenuCategory(response: Response): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as ThreadMeta[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Category not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Search threads
     * @param q Search query
     * @param mode (optional) Search mode. `0: title` or `1: op`
     * @param sort (optional) Sort threads by `0: latest` or `1: viral`
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuSearch(
        q: string,
        mode?: Mode,
        sort?: Sort3,
        page?: number,
        limit?: number
    ): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/menu/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mode === null) throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMenuSearch(_response);
        });
    }

    protected processMenuSearch(response: Response): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as ThreadMeta[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Get threads created by a user
     * @param id user id
     * @param page (optional) page number
     * @param limit (optional) limit per page
     * @return Success
     */
    menuHistory(id: number, page?: number, limit?: number): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/menu/history/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMenuHistory(_response);
        });
    }

    protected processMenuHistory(response: Response): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as ThreadMeta[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
                let result404: any = null;
                result404 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "User not found",
                    status,
                    _responseText,
                    _headers,
                    result404
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Get threads
     * @param threads Thread ids
     * @return Success
     */
    menuThreads(threads: number[]): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/menu/threads?";
        if (threads === undefined || threads === null)
            throw new Error(
                "The parameter 'threads' must be defined and cannot be null."
            );
        else
            threads &&
                threads.forEach((item) => {
                    url_ += "threads=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                Accept: "application/json",
            },
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMenuThreads(_response);
        });
    }

    protected processMenuThreads(response: Response): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then((_responseText) => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(
                              _responseText,
                              this.jsonParseReviver
                          ) as ThreadMeta[]);
                return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : (JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto);
                return throwException(
                    "Invalid request",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }
}

export interface OK {
    response: OKResponse;
}

export interface Token {
    token: string;
}

export interface ErrorDto {
    /** error message */
    error: string;
}

/** Vote. "U" means upvote. "D" means downvote. */
export enum Vote {
    U = "U",
    D = "D",
}

export interface User {
    /** user id */
    id: number;
    /** User name */
    name: string;
    sex: UserSex;
    /** date when user was created */
    createdAt: Date;
}

export interface Category {
    /** category id */
    id: number;
    /** category name */
    name: string;
}

export interface Image {
    cid: number;
    /** image source url */
    src: string;
}

export interface RemovedComment {
    id: number;
    removed: boolean;
}

/** Comment object with constants only (without upvotes, downvotes and replies) */
export interface CommentC {
    /** comment id */
    id: number;
    /** user created the comment */
    user: User;
    /** comment in stringified html */
    comment: string;
    /** comment converted to plain text */
    text: string;
    images: string[];
    createdAt: Date;
    /** shortened link to the comment */
    slink: string;
    quote?: Quote;
}

/** Comment object */
export interface Comment extends CommentC {
    /** number of downvotes */
    D?: number;
    /** number of upvotes */
    U?: number;
    /** list of comment ids that are replies to this comment */
    replies?: number[];
}

export interface Thread {
    /** thread id */
    id: number;
    /** thread title */
    title: string;
    category: number;
    op: User;
    /** number of comments in the thread (i.e. `conversation.length`) */
    c: number;
    /** An array of comments. Comment ids must not be duplicated. */
    conversation: (Conversation | RemovedComment)[];
    /** score of the thread (first comment) (`upvotes - downvotes`) */
    score: number;
    images: Image[];
    /** date when thread was created */
    createdAt: Date;
    /** date when thread was last modified */
    lastModified: Date;
    /** shortened link to the thread */
    slink: string;
    /** pinned comment */
    pin?: CommentC;
}

/** Thread metadata (no comments, images and pinned comment) */
export interface ThreadMeta {
    id: number;
    title: string;
    category: number;
    op: User;
    c: number;
    score: number;
    createdAt: Date;
    lastModified: Date;
    slink: string;
}

export enum Sort {
    Score = "score",
    Time = "time",
    Latest = "latest",
}

export interface Body {
    title: string;
    comment: string;
    rtoken: string;
    category: number;
}

export interface Body2 {
    comment: string;
    rtoken: string;
    quote?: number;
}

export interface Body3 {
    vote: Vote;
}

export interface Body4 {
    name: string;
}

export interface Id {}

export interface Body5 {
    /** Username or email */
    name: Name;
    pwd: string;
}

export interface Body6 {
    name: string;
    email: string;
    pwd: string;
    sex: UserSex;
    rtoken: string;
    /** Invite code, required if admin set register=invite See [register mode](https://docs.metahkg.org/docs/customize/registermode) */
    inviteCode?: string;
}

export interface Body7 {
    email: string;
    /** Verification code sent to email */
    code: string;
}

export interface Body8 {
    email: string;
    rtoken: string;
}

export interface Body9 {
    email: string;
    rtoken: string;
}

export interface Body10 {
    email: string;
    /** Verification code sent to email */
    code: string;
    pwd: string;
}

export enum Sort2 {
    _0 = 0,
    _1 = 1,
}

export enum Mode {
    _0 = 0,
    _1 = 1,
}

export enum Sort3 {
    _0 = 0,
    _1 = 1,
}

export interface Anonymous {
    id: number;
}

export interface Anonymous2 {
    id: number;
}

export interface Anonymous3 {
    /** Whether user is logged in */
    active: boolean;
}

export interface Anonymous4 {
    cid: number;
    vote: Vote;
}

export interface Anonymous5 extends OK {
    token: string;
}

export interface Anonymous6 extends User {
    /** Number of threads created by user */
    count: number;
}

export interface Anonymous7 {
    name: string;
}

export enum OKResponse {
    Ok = "ok",
}

export enum UserSex {
    M = "M",
    F = "F",
}

export interface Quote extends CommentC {}

/** Comment object with score */
export interface Conversation extends Comment {
    /** score of the comment (`upvotes - downvotes`) */
    score?: number;
}

export interface Name {}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(
        message: string,
        status: number,
        response: string,
        headers: { [key: string]: any },
        result: any
    ) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}
