//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from "axios";
import type {
    AxiosInstance,
    AxiosRequestConfig,
    AxiosResponse,
    CancelToken,
} from "axios";

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
        undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();

        this.instance.defaults.transformResponse = [];

        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : "https://dev.metahkg.org/api";
    }

    /**
     * Get threads
     * @param id array of thread ids
     * @return Success
     */
    threads(id: number[], cancelToken?: CancelToken | undefined): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            id &&
                id.forEach((item) => {
                    url_ += "id=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreads(_response);
            });
    }

    protected processThreads(response: AxiosResponse): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ThreadMeta[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Create thread
     * @return Success
     */
    threadCreate(body: Body, cancelToken?: CancelToken | undefined): Promise<Anonymous> {
        let url_ = this.baseUrl + "/threads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadCreate(_response);
            });
    }

    protected processThreadCreate(response: AxiosResponse): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user muted/banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Title already exists",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Recaptcha token invalid, or too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * Search threads
     * @param q Search query
     * @param mode (optional) Search mode. title or op
     * @param sort (optional) Sort threads by relevance, created or lastcomment
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    threadsSearch(
        q: string,
        mode?: Mode,
        sort?: Sort,
        page?: number,
        limit?: number,
        cancelToken?: CancelToken | undefined
    ): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/threads/search?";
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (mode === null) throw new Error("The parameter 'mode' cannot be null.");
        else if (mode !== undefined)
            url_ += "mode=" + encodeURIComponent("" + mode) + "&";
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadsSearch(_response);
            });
    }

    protected processThreadsSearch(response: AxiosResponse): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ThreadMeta[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Get thread
     * @param id thread id
     * @param page (optional) Page number. Ignored if start and end both specified.
     * @param limit (optional) Limit of comments per page.
     * @param sort (optional) Sort comments by score / time / latest. "time" means sorting acsendingly by created time, "latest" means desceningly, "score" means sorting descendingly by `upvotes - downvotes`
     * @param start (optional) Starting from comment id. If end is specified but start is not, start default to `(page - 1) * limit + 1`
     * @param end (optional) Ending at comment id. Must be greater or equal to start. If start is specified but end is not, end defaults to `page * limit`
     * @return Success
     */
    thread(
        id: number,
        page?: number,
        limit?: number,
        sort?: Sort2,
        start?: number,
        end?: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Thread> {
        let url_ = this.baseUrl + "/threads/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (start === null) throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&";
        if (end === null) throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined) url_ += "end=" + encodeURIComponent("" + end) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThread(_response);
            });
    }

    protected processThread(response: AxiosResponse): Promise<Thread> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Thread>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Thread>(null as any);
    }

    /**
     * Edit thread
     * @param id thread id
     * @return OK
     */
    threadEdit(
        id: number,
        body: Body2,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadEdit(_response);
            });
    }

    protected processThreadEdit(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Delete thread
     * @param id thread id
     * @return OK
     */
    threadDelete(
        id: number,
        body: Body3,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadDelete(_response);
            });
    }

    protected processThreadDelete(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get thread images
     * @param id thread id
     * @return Success
     */
    threadImages(id: number, cancelToken?: CancelToken | undefined): Promise<Image[]> {
        let url_ = this.baseUrl + "/threads/{id}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadImages(_response);
            });
    }

    protected processThreadImages(response: AxiosResponse): Promise<Image[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Image[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Image[]>(null as any);
    }

    /**
     * Get thread category
     * @param id thread id
     * @return Success
     */
    threadCategory(id: number, cancelToken?: CancelToken | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/threads/{id}/category";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadCategory(_response);
            });
    }

    protected processThreadCategory(response: AxiosResponse): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Category>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Pin comment
     * @param id thread id
     * @return OK
     */
    threadPin(
        id: number,
        body: Body4,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadPin(_response);
            });
    }

    protected processThreadPin(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unpin comment
     * @param id thread id
     * @return OK
     */
    threadUnpin(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/pin";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadUnpin(_response);
            });
    }

    protected processThreadUnpin(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Comment not pinned",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Star thread
     * @param id thread id
     * @return OK
     */
    threadStar(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadStar(_response);
            });
    }

    protected processThreadStar(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Thread already starred",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unstar thread
     * @param id thread id
     * @return OK
     */
    threadUnstar(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/unstar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processThreadUnstar(_response);
            });
    }

    protected processThreadUnstar(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Thread not starred",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Thread removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Create comment
     * @param id thread id
     * @return Success
     */
    commentCreate(
        id: number,
        body: Body5,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/threads/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentCreate(_response);
            });
    }

    protected processCommentCreate(response: AxiosResponse): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous2>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user muted/banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Recaptcha token invalid, or too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous2>(null as any);
    }

    /**
     * Get comment
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    comment(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Comment> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processComment(_response);
            });
    }

    protected processComment(response: AxiosResponse): Promise<Comment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Comment>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Comment>(null as any);
    }

    /**
     * Edit comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEdit(
        id: number,
        cid: number,
        body: Body6,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentEdit(_response);
            });
    }

    protected processCommentEdit(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Delete comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentDelete(
        id: number,
        cid: number,
        body: Body7,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentDelete(_response);
            });
    }

    protected processCommentDelete(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get replies
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentReplies(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Comment[]> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/replies";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentReplies(_response);
            });
    }

    protected processCommentReplies(response: AxiosResponse): Promise<Comment[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Comment[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Comment[]>(null as any);
    }

    /**
     * Get comment images.
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentImages(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Image[]> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/images";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentImages(_response);
            });
    }

    protected processCommentImages(response: AxiosResponse): Promise<Image[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Image[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Image[]>(null as any);
    }

    /**
     * Get votes
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentVotes(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/votes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentVotes(_response);
            });
    }

    protected processCommentVotes(response: AxiosResponse): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous3>(result200);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous3>(null as any);
    }

    /**
     * Get emotions
     * @param id thread id
     * @param cid comment id
     * @return Success
     */
    commentEmotions(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous4[]> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentEmotions(_response);
            });
    }

    protected processCommentEmotions(response: AxiosResponse): Promise<Anonymous4[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous4[]>(result200);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous4[]>(null as any);
    }

    /**
     * Get users who expressed the emotion
     * @param id thread id
     * @param cid comment id
     * @param emotion emotion to search for users
     * @return Success
     */
    commentEmotionUsers(
        id: number,
        cid: number,
        emotion: string,
        cancelToken?: CancelToken | undefined
    ): Promise<User[]> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion/{emotion}/users";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        if (emotion === undefined || emotion === null)
            throw new Error("The parameter 'emotion' must be defined.");
        url_ = url_.replace("{emotion}", encodeURIComponent("" + emotion));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentEmotionUsers(_response);
            });
    }

    protected processCommentEmotionUsers(response: AxiosResponse): Promise<User[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<User[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * Vote on comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentVote(
        body: Body8,
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/vote";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentVote(_response);
            });
    }

    protected processCommentVote(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Already voted, or too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Emotion on comment
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEmotionSet(
        id: number,
        cid: number,
        body: Body9,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentEmotionSet(_response);
            });
    }

    protected processCommentEmotionSet(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Delete emotion
     * @param id thread id
     * @param cid comment id
     * @return OK
     */
    commentEmotionDelete(
        id: number,
        cid: number,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/threads/{id}/comments/{cid}/emotion";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (cid === undefined || cid === null)
            throw new Error("The parameter 'cid' must be defined.");
        url_ = url_.replace("{cid}", encodeURIComponent("" + cid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCommentEmotionDelete(_response);
            });
    }

    protected processCommentEmotionDelete(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread or comment not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Emotion doesn't exist",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 410) {
            const _responseText = response.data;
            let result410: any = null;
            let resultData410 = _responseText;
            result410 = JSON.parse(resultData410);
            return throwException(
                "Comment removed",
                status,
                _responseText,
                _headers,
                result410
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get notifications
     * @return Success
     */
    meNotifications(cancelToken?: CancelToken | undefined): Promise<Notification[]> {
        let url_ = this.baseUrl + "/me/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeNotifications(_response);
            });
    }

    protected processMeNotifications(response: AxiosResponse): Promise<Notification[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Notification[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Notification[]>(null as any);
    }

    /**
     * Subscribe to notification
     * @return OK
     */
    meNotificationsSubscribe(
        body: Body10,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/me/notifications/subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeNotificationsSubscribe(_response);
            });
    }

    protected processMeNotificationsSubscribe(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unsubscribe to notification
     * @return OK
     */
    meNotificationsUnsubscribe(cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/me/notifications/unsubscribe";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeNotificationsUnsubscribe(_response);
            });
    }

    protected processMeNotificationsUnsubscribe(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get followed users
     * @return Success
     */
    meFollowing(cancelToken?: CancelToken | undefined): Promise<FollowedUser[]> {
        let url_ = this.baseUrl + "/me/following";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeFollowing(_response);
            });
    }

    protected processMeFollowing(response: AxiosResponse): Promise<FollowedUser[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<FollowedUser[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<FollowedUser[]>(null as any);
    }

    /**
     * Get blocked users
     * @return Success
     */
    meBlocked(cancelToken?: CancelToken | undefined): Promise<BlockedUser[]> {
        let url_ = this.baseUrl + "/me/blocked";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeBlocked(_response);
            });
    }

    protected processMeBlocked(response: AxiosResponse): Promise<BlockedUser[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<BlockedUser[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<BlockedUser[]>(null as any);
    }

    /**
     * Get starred threads
     * @return Success
     */
    meStarred(cancelToken?: CancelToken | undefined): Promise<Star[]> {
        let url_ = this.baseUrl + "/me/starred";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeStarred(_response);
            });
    }

    protected processMeStarred(response: AxiosResponse): Promise<Star[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Star[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Star[]>(null as any);
    }

    /**
     * Get votes in thread
     * @param id thread id
     * @return Success
     */
    meVotesThread(
        id: number,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous5[]> {
        let url_ = this.baseUrl + "/me/votes/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processMeVotesThread(_response);
            });
    }

    protected processMeVotesThread(response: AxiosResponse): Promise<Anonymous5[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous5[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Thread not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous5[]>(null as any);
    }

    /**
     * Get categories
     * @return Success
     */
    categories(cancelToken?: CancelToken | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategories(_response);
            });
    }

    protected processCategories(response: AxiosResponse): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Category[]>(result200);
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * Create category
     * @return OK
     */
    categoryCreate(body: Body11, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategoryCreate(_response);
            });
    }

    protected processCategoryCreate(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Category already exists",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get category
     * @param id category id
     * @return Success
     */
    category(id: number, cancelToken?: CancelToken | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategory(_response);
            });
    }

    protected processCategory(response: AxiosResponse): Promise<Category> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Category>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * Edit a category
     * @param id category id
     * @return OK
     */
    categoryEdit(
        id: number,
        body: Body12,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategoryEdit(_response);
            });
    }

    protected processCategoryEdit(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Delete a category
     * @param id category id
     * @return OK
     */
    categoryDelete(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategoryDelete(_response);
            });
    }

    protected processCategoryDelete(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get threads in a category
     * @param id category id
     * @param sort (optional) Sort threads by latest or viral
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    categoryThreads(
        id: number,
        sort?: Sort3,
        page?: number,
        limit?: number,
        cancelToken?: CancelToken | undefined
    ): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/categories/{id}/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processCategoryThreads(_response);
            });
    }

    protected processCategoryThreads(response: AxiosResponse): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ThreadMeta[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Category not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Get user profile
     * @param id user id
     * @return Success
     */
    userProfile(id: number, cancelToken?: CancelToken | undefined): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserProfile(_response);
            });
    }

    protected processUserProfile(response: AxiosResponse): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous6>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    /**
     * Edit user info
     * @param id user id
     * @return Success
     */
    userEdit(
        id: number,
        body: Body13,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserEdit(_response);
            });
    }

    protected processUserEdit(response: AxiosResponse): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous7>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Name already taken",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous7>(null as any);
    }

    /**
     * Get user name
     * @param id user id
     * @return Success
     */
    userName(id: number, cancelToken?: CancelToken | undefined): Promise<Anonymous8> {
        let url_ = this.baseUrl + "/users/{id}/name";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserName(_response);
            });
    }

    protected processUserName(response: AxiosResponse): Promise<Anonymous8> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous8>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous8>(null as any);
    }

    /**
     * Get user avatar
     * @param id user id
     * @return Success
     */
    userAvatar(id: number, cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                Accept: "image/png",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserAvatar(_response);
            });
    }

    protected processUserAvatar(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers["content-disposition"]
                : undefined;
            let fileNameMatch = contentDisposition
                ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
                      contentDisposition
                  )
                : undefined;
            let fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[3] || fileNameMatch[2]
                    : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition
                    ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                    : undefined;
                fileName =
                    fileNameMatch && fileNameMatch.length > 1
                        ? fileNameMatch[1]
                        : undefined;
            }
            return Promise.resolve({
                fileName: fileName,
                status: status,
                data: new Blob([response.data], {
                    type: response.headers["content-type"],
                }),
                headers: _headers,
            });
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User or avatar not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Upload avatar
     * @param id user id
     * @param avatar (optional) Avatar image. Must be smaller than 2MB. Png, jpg, jpeg, jfif, svg, gif, webp are supported.
     * @return OK
     */
    userAvatarUpload(
        id: number,
        avatar?: FileParameter,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (avatar === null || avatar === undefined)
            throw new Error("The parameter 'avatar' cannot be null.");
        else
            content_.append(
                "avatar",
                avatar.data,
                avatar.fileName ? avatar.fileName : "avatar"
            );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserAvatarUpload(_response);
            });
    }

    protected processUserAvatarUpload(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 413) {
            const _responseText = response.data;
            let result413: any = null;
            let resultData413 = _responseText;
            result413 = JSON.parse(resultData413);
            return throwException(
                "File too large",
                status,
                _responseText,
                _headers,
                result413
            );
        } else if (status === 415) {
            const _responseText = response.data;
            let result415: any = null;
            let resultData415 = _responseText;
            result415 = JSON.parse(resultData415);
            return throwException(
                "File type not supported",
                status,
                _responseText,
                _headers,
                result415
            );
        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422 = _responseText;
            result422 = JSON.parse(resultData422);
            return throwException(
                "File unprocessable",
                status,
                _responseText,
                _headers,
                result422
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Delete avatar
     * @param id user id
     * @return OK
     */
    userAvatarDelete(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserAvatarDelete(_response);
            });
    }

    protected processUserAvatarDelete(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Avatar not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Get threads created by a user
     * @param id user id
     * @param sort (optional) Sort threads by created or lastcomment
     * @param page (optional) page number
     * @param limit (optional) number of threads per page
     * @return Success
     */
    userThreads(
        id: number,
        sort?: Sort4,
        page?: number,
        limit?: number,
        cancelToken?: CancelToken | undefined
    ): Promise<ThreadMeta[]> {
        let url_ = this.baseUrl + "/users/{id}/threads?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserThreads(_response);
            });
    }

    protected processUserThreads(response: AxiosResponse): Promise<ThreadMeta[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<ThreadMeta[]>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<ThreadMeta[]>(null as any);
    }

    /**
     * Follow user
     * @param id user id
     * @return OK
     */
    userFollow(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/follow";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserFollow(_response);
            });
    }

    protected processUserFollow(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User already followed",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unfollow user
     * @param id user id
     * @return OK
     */
    userUnfollow(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/unfollow";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserUnfollow(_response);
            });
    }

    protected processUserUnfollow(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User not followed",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Block user
     * @param id user id
     * @return OK
     */
    userBlock(
        id: number,
        body: Body14,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/block";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserBlock(_response);
            });
    }

    protected processUserBlock(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User already blocked",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unblock user
     * @param id user id
     * @return OK
     */
    userUnblock(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/unblock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserUnblock(_response);
            });
    }

    protected processUserUnblock(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User not blocked",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Mute user
     * @param id user id
     * @return OK
     */
    userMute(
        id: number,
        body: Body15,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/mute";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserMute(_response);
            });
    }

    protected processUserMute(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User is an admin. Cannot mute.",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unmute user
     * @param id user id
     * @return OK
     */
    userUnmute(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/unmute";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserUnmute(_response);
            });
    }

    protected processUserUnmute(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User not muted",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Ban user
     * @param id user id
     * @return OK
     */
    userBan(
        id: number,
        body: Body16,
        cancelToken?: CancelToken | undefined
    ): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/ban";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserBan(_response);
            });
    }

    protected processUserBan(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User is an admin. Cannot ban.",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Unban user
     * @param id user id
     * @return OK
     */
    userUnban(id: number, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/users/{id}/unban";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processUserUnban(_response);
            });
    }

    protected processUserUnban(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "User not banned",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Login
     * @return Success
     */
    authLogin(
        body: Body17,
        cancelToken?: CancelToken | undefined
    ): Promise<LoginSuccess> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthLogin(_response);
            });
    }

    protected processAuthLogin(response: AxiosResponse): Promise<LoginSuccess> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LoginSuccess>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Login failed",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Email verification needed",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<LoginSuccess>(null as any);
    }

    /**
     * Logout
     * @return OK
     */
    authLogout(cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthLogout(_response);
            });
    }

    protected processAuthLogout(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Register
     * @return Success, verification email sent.
     */
    authRegister(body: Body18, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthRegister(_response);
            });
    }

    protected processAuthRegister(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Bad request / registration disabled / invalid invite code",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Email or username already in use",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Verify email
     * @return Success
     */
    authVerify(
        body: Body19,
        cancelToken?: CancelToken | undefined
    ): Promise<LoginSuccess> {
        let url_ = this.baseUrl + "/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthVerify(_response);
            });
    }

    protected processAuthVerify(response: AxiosResponse): Promise<LoginSuccess> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LoginSuccess>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Code incorrect or expired, or email not found",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<LoginSuccess>(null as any);
    }

    /**
     * Resend verification email
     * @return Success
     */
    authResend(body: Body20, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/auth/resend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthResend(_response);
            });
    }

    protected processAuthResend(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Email not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Recaptcha token invalid, or too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Forgot password
     * @return Success
     */
    authForgot(body: Body21, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/auth/forgot";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthForgot(_response);
            });
    }

    protected processAuthForgot(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Recaptcha token invalid, or too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Reset password
     * @return Success
     */
    authReset(
        body: Body22,
        cancelToken?: CancelToken | undefined
    ): Promise<LoginSuccess> {
        let url_ = this.baseUrl + "/auth/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthReset(_response);
            });
    }

    protected processAuthReset(response: AxiosResponse): Promise<LoginSuccess> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<LoginSuccess>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "User not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<LoginSuccess>(null as any);
    }

    /**
     * Get current session
     * @return Success
     */
    authSessionCurrent(cancelToken?: CancelToken | undefined): Promise<Session> {
        let url_ = this.baseUrl + "/auth/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthSessionCurrent(_response);
            });
    }

    protected processAuthSessionCurrent(response: AxiosResponse): Promise<Session> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Session>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Session>(null as any);
    }

    /**
     * Get active sessions
     * @return Success
     */
    authSessions(cancelToken?: CancelToken | undefined): Promise<Session[]> {
        let url_ = this.baseUrl + "/auth/sessions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthSessions(_response);
            });
    }

    protected processAuthSessions(response: AxiosResponse): Promise<Session[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Session[]>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Session[]>(null as any);
    }

    /**
     * Get session by id
     * @param id session id
     * @return Success
     */
    authSession(id: string, cancelToken?: CancelToken | undefined): Promise<Session> {
        let url_ = this.baseUrl + "/auth/sessions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthSession(_response);
            });
    }

    protected processAuthSession(response: AxiosResponse): Promise<Session> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Session>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Session not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Session>(null as any);
    }

    /**
     * Revoke session by id
     * @param id session id
     * @return OK
     */
    authSessionRevoke(id: string, cancelToken?: CancelToken | undefined): Promise<OK> {
        let url_ = this.baseUrl + "/auth/sessions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthSessionRevoke(_response);
            });
    }

    protected processAuthSessionRevoke(response: AxiosResponse): Promise<OK> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<OK>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Unauthorized",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Forbidden: permission denied or user banned by an admin",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Session not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText;
            result409 = JSON.parse(resultData409);
            return throwException(
                "Failed to revoke an older session",
                status,
                _responseText,
                _headers,
                result409
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<OK>(null as any);
    }

    /**
     * Refresh session
     * @param id session id
     * @return Success
     */
    authSessionRefresh(
        id: string,
        body: Body23,
        cancelToken?: CancelToken | undefined
    ): Promise<Anonymous9> {
        let url_ = this.baseUrl + "/auth/sessions/{id}/refresh";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processAuthSessionRefresh(_response);
            });
    }

    protected processAuthSessionRefresh(response: AxiosResponse): Promise<Anonymous9> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = JSON.parse(resultData200);
            return Promise.resolve<Anonymous9>(result200);
        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText;
            result400 = JSON.parse(resultData400);
            return throwException(
                "Invalid request",
                status,
                _responseText,
                _headers,
                result400
            );
        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText;
            result401 = JSON.parse(resultData401);
            return throwException(
                "Invalid refresh token",
                status,
                _responseText,
                _headers,
                result401
            );
        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText;
            result403 = JSON.parse(resultData403);
            return throwException(
                "Refreshing with another ip is not allowed (sameIp is enabled for this session)",
                status,
                _responseText,
                _headers,
                result403
            );
        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText;
            result404 = JSON.parse(resultData404);
            return throwException(
                "Session not found",
                status,
                _responseText,
                _headers,
                result404
            );
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<Anonymous9>(null as any);
    }

    /**
     * Get server public key
     * @return Success
     */
    serverPublicKey(cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/server/publickey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processServerPublicKey(_response);
            });
    }

    protected processServerPublicKey(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<string>(result200);
        } else if (status === 429) {
            const _responseText = response.data;
            let result429: any = null;
            let resultData429 = _responseText;
            result429 = JSON.parse(resultData429);
            return throwException(
                "Too many requests",
                status,
                _responseText,
                _headers,
                result429
            );
        } else if (status === 500) {
            const _responseText = response.data;
            let result500: any = null;
            let resultData500 = _responseText;
            result500 = JSON.parse(resultData500);
            return throwException(
                "Internal server error",
                status,
                _responseText,
                _headers,
                result500
            );
        } else if (status === 502) {
            const _responseText = response.data;
            let result502: any = null;
            let resultData502 = _responseText;
            result502 = JSON.parse(resultData502);
            return throwException(
                "Bad gateway",
                status,
                _responseText,
                _headers,
                result502
            );
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(
                "An unexpected server error occurred.",
                status,
                _responseText,
                _headers
            );
        }
        return Promise.resolve<string>(null as any);
    }
}

export interface OK {
    success: boolean;
}

export interface Session {
    /** 30-digit random session id */
    id: string;
    /** session created date */
    createdAt: Date;
    /** session expire date */
    exp: Date;
    /** user agent used to create the session */
    userAgent: string;
    sameIp?: boolean;
}

export interface LoginSuccess extends Session {
    token: string;
    refreshToken: string;
    /** sha256 hash of client's ip */
    ip: string;
}

export function isLoginSuccess(object: any): object is LoginSuccess {
    return object && object[""] === "LoginSuccess";
}

export interface ErrorDto {
    /** status code */
    statusCode: number;
    /** error message */
    error: string;
}

export interface Notification {
    /** title of the notification */
    title: string;
    /** when the notification was created */
    createdAt: Date;
    options: Options;
}

/** Vote. "U" means upvote. "D" means downvote. */
export type Vote = "U" | "D";

export interface User {
    /** user id */
    id: number;
    /** User name */
    name: string;
    sex: UserSex;
    role: UserRole;
}

/** Admin actions / responses */
export interface Admin {
    edits?: Edits[];
    /** admin replies */
    replies?: Replies[];
}

/** Followed user (user object with follow date) */
export interface FollowedUser extends User {
    /** follow date */
    date: Date;
}

export function isFollowedUser(object: any): object is FollowedUser {
    return object && object[""] === "FollowedUser";
}

/** Blocked user (user object with block date and reason) */
export interface BlockedUser extends User {
    /** block date */
    date: Date;
    /** block reason */
    reason: string;
}

export function isBlockedUser(object: any): object is BlockedUser {
    return object && object[""] === "BlockedUser";
}

export interface Category {
    /** category id */
    id: number;
    /** category name */
    name: string;
    /** category tags */
    tags?: string[];
    /** category is hidden */
    hidden?: boolean;
    /** category is pinned */
    pinned?: boolean;
}

export interface Image {
    cid: number;
    /** image source url */
    src: string;
}

export interface RemovedComment {
    id: number;
    removed: boolean;
}

/** Comment object */
export interface Comment {
    /** comment id */
    id: number;
    /** user created the comment */
    user: User;
    /** comment in stringified html */
    comment: string;
    /** comment converted to plain text */
    text: string;
    images: string[];
    createdAt: Date;
    /** shortened link to the comment */
    slink: string;
    quote?: Quote;
    /** number of downvotes */
    D?: number;
    /** number of upvotes */
    U?: number;
    /** list of comment ids that are replies to this comment */
    replies?: number[];
    /** list of emotions users have expressed */
    emotions?: Anonymous4[];
    admin?: Admin;
}

/** Comment object with constants only (without upvotes, downvotes, replies and emotions) */
export interface CommentC {
    id: number;
    user: User;
    comment: string;
    text: string;
    images: string[];
    createdAt: Date;
    slink: string;
    quote?: Quote;
}

export interface Thread {
    /** thread id */
    id: number;
    /** thread title */
    title: string;
    category: number;
    op: User;
    /** number of comments in the thread (i.e. `conversation.length`) */
    count: number;
    /** An array of comments. Comment ids must not be duplicated. */
    conversation: (Conversation | RemovedComment)[];
    /** score of the thread (first comment) (`upvotes - downvotes`) */
    score: number;
    images: Image[];
    /** date when thread was created */
    createdAt: Date;
    /** date when thread was last modified */
    lastModified: Date;
    /** shortened link to the thread */
    slink: string;
    /** pinned comment */
    pin?: CommentC;
    admin?: Admin;
}

/** Thread metadata (no comments, images and pinned comment) */
export interface ThreadMeta {
    id: number;
    title: string;
    category: number;
    op: User;
    count: number;
    score: number;
    createdAt: Date;
    lastModified: Date;
    slink: string;
}

/** star thread record */
export interface Star {
    id: number;
    /** date when star was created */
    date: Date;
}

export interface Body {
    title: string;
    comment: string;
    rtoken: string;
    category: number;
}

export type Mode = "title" | "op";

export type Sort = "relevance" | "created" | "lastcomment";

export type Sort2 = "score" | "time" | "latest";

export interface Body2 {
    title?: string;
    category?: number;
    reason: string;
}

export interface Body3 {
    /** Reason for removing comment */
    reason: string;
}

export interface Body4 {
    cid: number;
}

export interface Body5 {
    comment: string;
    rtoken: string;
    quote?: number;
}

export interface Body6 {
    comment: string;
    /** Reason for editing comment */
    reason: string;
}

export interface Body7 {
    /** Reason for removing comment */
    reason: string;
}

export interface Body8 {
    vote: Vote;
}

export interface Body9 {
    emotion: string;
}

/** Endpoint and keys for push notifications. */
export interface Body10 {
    /** Push notification endpoint */
    endpoint: string;
    keys: Keys;
}

export interface Body11 {
    name: string;
    hidden?: boolean;
    tags?: string[];
    pinned?: boolean;
}

export interface Body12 {
    name?: string;
    tags?: string[];
    pinned?: boolean;
}

export type Sort3 = "latest" | "viral";

export interface Body13 {
    name?: string;
    sex?: UserSex;
}

export type Sort4 = "created" | "lastcomment";

export interface Body14 {
    /** Reason for blocking user */
    reason?: string;
}

export interface Body15 {
    /** Reason for muting the user */
    reason: string;
    /** expiration (optional) */
    exp?: Date;
}

export interface Body16 {
    /** Reason for banning the user */
    reason: string;
    /** expiration (optional) */
    exp?: Date;
}

export interface Body17 {
    /** Username or email */
    name: string;
    password: string;
    rtoken: string;
    sameIp?: boolean;
}

export interface Body18 {
    name: string;
    email: string;
    password: string;
    sex: UserSex;
    rtoken: string;
    /** Invite code, required if admin set register=invite See [register mode](https://docs.metahkg.org/docs/customize/registermode) */
    inviteCode?: string;
}

export interface Body19 {
    email: string;
    code: string;
    rtoken: string;
    sameIp?: boolean;
}

export interface Body20 {
    email: string;
    rtoken: string;
}

export interface Body21 {
    email: string;
    rtoken: string;
}

export interface Body22 {
    email: string;
    code: string;
    password: string;
    rtoken: string;
    sameIp?: boolean;
}

export interface Body23 {
    refreshToken: string;
}

export interface Anonymous {
    id: number;
}

export interface Anonymous2 {
    id: number;
}

export interface Anonymous3 {
    U?: number;
    D?: number;
}

export interface Anonymous4 {
    user: number;
    emotion: string;
}

export interface Anonymous5 {
    cid: number;
    vote: Vote;
}

export interface Anonymous6 extends User {
    /** Number of threads created by user */
    count: number;
    /** Date and time when user was created */
    createdAt?: Date;
}

export function isAnonymous6(object: any): object is Anonymous6 {
    return object && object[""] === "Anonymous6";
}

export interface Anonymous7 {
    token: string;
}

export interface Anonymous8 {
    name: string;
}

export interface Anonymous9 {
    token: string;
    refreshToken: string;
}

export interface Options {
    /** body of the notification */
    body: string;
    data: Data;
}

export type UserSex = "M" | "F";

export type UserRole = "admin" | "user";

export interface Edits {
    admin: User;
    /** reason for editing */
    reason: string;
    date: Date;
}

export interface Replies {
    admin: User;
    /** admin's reply */
    reply: string;
    date: Date;
}

export interface Quote extends CommentC {
    [key: string]: any;
}

export function isQuote(object: any): object is Quote {
    return object && object[""] === "Quote";
}

/** Comment object with score */
export interface Conversation extends Comment {
    /** score of the comment (`upvotes - downvotes`) */
    score?: number;
}

export function isConversation(object: any): object is Conversation {
    return object && object[""] === "Conversation";
}

export interface Keys {
    /** auth key */
    auth: string;
    /** p256dh key */
    p256dh: string;
}

export interface Data {
    /** type of the notification */
    type: DataType;
    /** the link that should be opened on click */
    url: string;
    threadId: number;
    commentId?: number;
}

export type DataType = "thread" | "comment" | "reply" | "emotion" | "votes";

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(
        message: string,
        status: number,
        response: string,
        headers: { [key: string]: any },
        result: any
    ) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj?: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
